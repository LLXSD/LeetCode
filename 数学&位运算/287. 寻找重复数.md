## 题目描述
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有一个重复的整数 ，找出这个重复的数 。


## 解决思路
题解：哈希；快慢指针；二进制位运算

将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 1 还是 0 就可以按位还原出重复的数是什么。考虑到第 i 位，我们记 nums 数组中二进制展开后第 i 位为 1 的数有 x 个，数字[1,n]这 n 个数二进制展开后第 i 位为 1 的数有 y 个，那么重复的数第 i 位为 1 当且仅当 x>y。

以[1,3,4,2,2]为例，如下的表格列出了每个数字二进制下每一位是 1 还是 0 以及对应位的 x 和 y 是多少：
 
那么按之前说的我们发现只有第1 位x>y ，所以按位还原后 target=(010) =2

如果测试用例的数组中 target 出现了两次，其余的数各出现了一次，且 target 的第 i 位为 1，那么 nums 数组中第 i 位 1 的个数 x 恰好比 y 大一。如果target 的第 i 位为 0，那么两者相等。

如果测试用例的数组中 target 出现了三次及以上，那么必然有一些数不在 nums 数组中了，这个时候相当于我们用 target 去替换了这些数，我们考虑替换的时候对 x 的影响：
- 如果被替换的数第 i 位为 1，且 target 第 i 位为 1：x 不变，满足 x>y。
- 如果被替换的数第 i 位为 0，且 target 第 i 位为 1：x 加一，满足 x>y。
- 如果被替换的数第 i 位为 1，且 target 第 i 位为 0：x 减一，满足 x≤y。
- 如果被替换的数第 i 位为 0，且 target 第 i 位为 0：x 不变，满足 x≤y。

也就是说如果 target 第 i 位为 1，那么每次替换后只会使 x 不变或增大，如果为 0，只会使 x 不变或减小，始终满足 x>y时 target 第 i 位为 1，否则为 0，因此我们只要按位还原这个重复的数即可。

## 代码
```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n=len(nums)-1
        ans=0
        bit_max=31
        while(~(n >> bit_max)==1):  #确定二进制下最高位是多少（有多少位）~表示按位取非
            bit_max-=1 
        for bit in range(bit_max+1):
            x=0
            y=0
            for i in range(n+1):
                if nums[i] & (1<<bit):   #左移动运算符<<：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。按位与运算符&：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0
                    x+=1
                if i>=1 and (i & (1<<bit)):
                    y+=1
            if x>y:
                ans |=1<<bit  #按位或运算符|：只要对应的二个二进位有一个为1时，结果位就为1。
        return ans

```
